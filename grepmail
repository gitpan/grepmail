#!/usr/bin/perl -w

# use perl                                  -*- mode: Perl; -*-
eval 'exec perl -S $0 "$@"'
  if $running_under_some_shell;

use vars qw($running_under_some_shell);         # no whining!

require 5.003;

# grepmail version 2.0.1

# Grepmail searches a normal or gzip'ed mailbox for a given regular expression,
# and returns those emails that match it. Piped input is allowed, and date
# restrictions are supported.

# Do a pod2text on this file to get full documentation, or pod2man to get
# man pages.

# Written by David Coppit (coppit@cs.virginia.edu,
#  http://www.cs.virginia.edu/~dwc3q/index.html)

# Please send me any modifications you make. (for the better, that is. :)

# This code is distributed under the GNU General Public License (GPL). See
# http://www.opensource.org/gpl-license.html and http://www.opensource.org/.

# Version History (major changes only)
# 2.0 Added POD documentation at the end of the script (thanks, Jeffrey
#   Haemer <jsh@boulder.qms.com>). -h for headers only -b for body only
# 1.9 "Ignore empty files" by Gerald Pfeifer <pfeifer@dbai.tuwien.ac.at>.
#   Emails without dates are now automatically output no matter what the
#   date specification is. (Better safe than sorry!)
# 1.7 Sped up by Andrew Johnson. It no longer looks for dates unless
#   the email matches the search string.
# 1.6 removed use of Compress::Zlib because it was 30% slower, complicated the
#   code, and because any user with gzip'd mail has zcat...
# 1.5 Andrew Johnson <ajohnson@gpu.srv.ualberta.ca> fixed a couple of bugs.
# 1.4 Incorporated conditional loading of the date module, use of
#   compress::Zlib instead of shelling out to gunzip, as well as some bug
#   fixes, as submitted by Andrew Johnson <ajohnson@gpu.srv.ualberta.ca>
#   (Many thanks!). Also restructured the code a bit.
# 1.3 Made it pipeable so you can do:
#   grepmail <pattern> file | grepmail <pattern>
# 1.1 Support for dates.
# 1.0 Initial version, with -v -i, and gzip support

use strict;
use FileHandle;
use Getopt::Std;
use Carp;

my (%opts, $pattern, $unzipMethod);

BEGIN
{
  getopt("d",\%opts);

  if ($opts{d})
  {
    unless (eval "require Date::Manip")
    {
      die "You specified -d, but do not have Date::Manip. Get it from CPAN.\n";
    }

    import Date::Manip;
  }
}

# There should be at least one thing left: the pattern. (If no
# file is given, then STDIN is used.)

if ($#ARGV < 0)
{
  print <<EOF;
usage: grepmail [-vihb] [-d \"datespec\"] <expr> <files...>

-h Search headers only
-b Search body only
-i Ignore case in the search expression
-v Output emails that don't match the expression

Date specifications must be of the form of:
a date like "today", "1st thursday in June 1992", "05/10/93",
  "12:30 Dec 12th 1880", "8:00pm december tenth",
OR "before", "after", or "since", followed by a date as defined above,
OR "between <date> and <date>", where <date> is defined as above.

Files can be ASCII or gzip'd ASCII.

You can also pipe STDIN to grepmail, using gunzip to decompress mail folders.
EOF

exit (1);
}

# Grab the search pattern from the arg list
$pattern = shift @ARGV;

# Make it insensitive if we need to
$pattern = "(?i)$pattern" if ($opts{i});

my ($daterestriction, $date1, $date2);

if ($opts{d})
{
  ($daterestriction,$date1,$date2) = &ProcessDate($opts{d});
}
else
{
  $daterestriction = "none";
}

# If the user provided input files...
if (@ARGV)
{
  # For each input file...
  my $file;
  foreach $file (@ARGV)
  {
    # First of all, ignore empty files.
    next if -z $file;

    # If it's not a gzipped file
    if ($file !~ /\.(gz|Z)$/)
    {
      warn "** Skipping binary file: '$file' **\n" and next if -B $file;
      my $fileHandle = new FileHandle;
      $fileHandle->open($file) || die "Can't open $file.\n";
      ProcessMailFile($fileHandle);
      $fileHandle->close();
    }
    # If it is a gzipped file
    else
    {
      my $tempFile = "/tmp/$$";
      `zcat $file > $tempFile`;
      my $fileHandle = new FileHandle;
      $fileHandle->open($tempFile)
          || die "Can't open temporary file used to decompress the file $file.\n";
      ProcessMailFile($fileHandle);
      $fileHandle->close();
      unlink $tempFile;
    }
    
  }
}
# Using STDIN
else
{ 
  my $fileHandle = new FileHandle;
  $fileHandle->open("<&STDIN") || die "Can't dup STDIN $!";

  # If it looks binary, try to unzip it.
  if (-B $fileHandle)
  {
    binmode $fileHandle;
    my $tempFile = "/tmp/$$";
    open(TMP,"|zcat >$tempFile") || die "Can't create $tempFile $!";
    binmode TMP;
    print TMP while <$fileHandle>;
    close TMP;
    $fileHandle->close()||die "Error writing $tempFile $!";
    $fileHandle->open($tempFile) || die "Can't open $tempFile $!";
    ProcessMailFile($fileHandle);
    $fileHandle->close();
    unlink $tempFile;      
  }
  # Otherwise process it directly
  else
  {
    ProcessMailFile($fileHandle);
    $fileHandle->close();
  }
}
#-------------------------------------------------------------------------------

sub ProcessMailFile ($)
{
my $fileHandle = shift @_;
my ($whole_email,$header,$body,$found);
my @email;
my $firstLine = 1;
while (<$fileHandle>)
{
  # Code ripped from Mail::Util
  if ((!$firstLine && /^From .*\d{4}/) || eof) 
  {
    push @email,$_ if eof;
    $whole_email = join("",@email);

    $whole_email =~ /\n\n/o;
    my $header = "$`\n";
    my $body = $';

    if ($opts{b})
    {
      $found = ($body =~ /$pattern/o);
    }
    elsif ($opts{h})
    {
      $found = ($header =~ /$pattern/o);
    }
    else
    {
      $found = ($whole_email =~ /$pattern/o);
    }

    $found = !$found if ($opts{v});

    if (scalar(@email) && $found && &CheckDate($whole_email))
    {
      print $whole_email;
    }

    @email = ( $_ );
    $found = 0;
  }
  else
  {
    $firstLine = 0;
    push(@email, $_);
  }
}

}


#-------------------------------------------------------------------------------

sub CheckDate($)
{
my $email = shift;
my ($emailDate, $isInDate);
$emailDate = "";
$isInDate = 0;

if ($opts{d})
{
  # The email might not have a date. In this case, print it out anyway.
  if ($email =~ /^Date:\s*(\S*\s*\S*\s*\S*\s*\S*\s*\S*)/m)
  {
    $emailDate = &ParseDate($1);
    $isInDate = &IsInDate($emailDate,$daterestriction,$date1,$date2);
  }
  else
  {
    $isInDate = 1;
  }
}
else
{
  $isInDate = 1;
}

return $isInDate;

}

#-------------------------------------------------------------------------------

# Figure out what kind of date restriction they want, and what the dates in
# question are.
sub ProcessDate($)
{
my ($daterestriction, $date1, $date2);

if(!defined($_[0]))
{
  return ("none","","");
}

my $datestring = $_[0];

if ($datestring =~ /^before (.*)/)
{
  $daterestriction = "before";
  $date1 = &ParseDate($1);
  $date2 = "";

  if (!$date1)
  {
    die "\"$1\" is not a valid date\n";
  }
}
elsif ($datestring =~ /^(after |since )(.*)/)
{
  $daterestriction = "after";
  $date1 = &ParseDate($2);
  $date2 = "";

  if (!$date1)
  {
    die "\"$2\" is not a valid date\n";
  }
}
elsif ($datestring =~ /^between (.*) and (.*)/)
{
  $daterestriction = "between";
  $date1 = &ParseDate($1);
  $date2 = &ParseDate($2);

  if (!$date1)
  {
    die "\"$1\" is not a valid date\n";
  }
  if (!$date2)
  {
    die "\"$2\" is not a valid date\n";
  }

  # Swap the dates if the user gave them backwards.
  if ($date1 gt $date2)
  {
    my $temp;
    $temp = $date1;
    $date1 = $date2;
    $date2 = $temp;
  }

}
elsif ($date1 = &ParseDate($datestring))
{
  $daterestriction = "on"
}
else
{
  die "Invalid date specification. Use \"$0 -h\" for help\n";
}

return ($daterestriction,$date1,$date2);

}

#-------------------------------------------------------------------------------

sub IsInDate($$$$)
{
my ($emailDate,$daterestriction,$date1,$date2);
$emailDate = shift @_;
$daterestriction = shift @_;
$date1 = shift @_;
$date2 = shift @_;

# Here we do the date checking.
if ($daterestriction eq "none")
{
  return 1;
}
else
{
  if ($daterestriction eq "before")
  {
    if ($emailDate lt $date1)
    {
      return 1;
    }
    else
    {
      return 0;
    }
  }
  elsif ($daterestriction eq "after")
  {
    if ($emailDate gt $date1)
    {
      return 1;
    }
    else
    {
      return 0;
    }
  }
  elsif ($daterestriction eq "on")
  {
    if (&UnixDate($emailDate,"%m %d %Y") eq &UnixDate($date1,"%m %d %Y"))
    {
      return 1;
    }
    else
    {
      return 0;
    }
  }
  elsif ($daterestriction eq "between")
  {
    if (($emailDate gt $date1) && ($emailDate lt $date2))
    {
      return 1;
    }
    else
    {
      return 0;
    }
  }
}

}

#-------------------------------------------------------------------------------

=head1 NAME

grepmail - search mailboxes for mail matching a regular expression

=head1 SYNOPSIS

  grepmail [-bhvi] [-d "datespec"] <regex> [mailbox ...]

=head1 DESCRIPTION

=over 2

I<grepmail> looks for mail messages containing a pattern, and prints the
resulting messages on standard out.

By default I<grepmail> looks in both header and body for the specified pattern.

When redirected to a file, the result is another mailbox, which can, in turn,
be handled by standard User Agents, such as I<elm>, or even used as input for
another instance of I<grepmail>.

=back

=head1 OPTIONS AND ARGUMENTS

Many of the options and arguments are analogous to those of grep.

=over 8

=item B<pattern>

The pattern to search for in the mail message.  May be any Perl regular
expression, but should be quoted on the command line to protect against
globbing (shell expansion).

=item B<mailbox>

Mailboxes must be traditional, UNIX C</bin/mail> mailbox format.  The
mailboxes may be zipped by gzip, in which case zcat must be installed on the
system.  If no mailbox is specified, takes input from stdin.

=item B<-b>

Look only in the bodies of mail messages.

=item B<-h>

Look only in the headers of mail messages.

=item B<-i>

Make the search case-insensitive (by analogy to I<grep -i>).

=item B<-v>

Invert the sense of the search, (by analogy to I<grep -v>).

=item B<-d>

Date specifications must be of the form of:
  - a date like "today", "1st thursday in June 1992", "05/10/93", "12:30 Dec 12th 1880", "8:00pm december tenth",
  - OR "before", "after", or "since", followed by a date as defined above,
  - OR "between <date> and <date>", where <date> is defined as above.

=back

=head1 EXAMPLES

Get all email that you mailed yesterday

  grepmail -d "yesterday" . sent-mail

Get all email that you mailed before the first thursday in June 1998 that
pertains to research:

  grepmail -d "before 1st thursday in June 1992" research sent-mail

Get all email you received since 8/20/98 that wasn't about research or your
job, ignoring case:

  grepmail -i -d "since 8/20/98" -v "(research|job)" saved-mail

Get all email about mime but not about Netscape:

  grepmail -b mime saved-mail | grepmail -v Netscape

=head1 AUTHOR

  David Coppit, <coppit@cs.virginia.edu>

=head1 SEE ALSO

elm(1), mail(1), grep(1), perl(1), printmail(1), Mail::Internet(3)
Crocker,  D.  H., Standard for the
Format of Arpa Internet Text Messages, RFC822.

=cut

