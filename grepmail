#!/usr/bin/perl

# use perl                                  -*- mode: Perl; -*-
eval 'exec perl -S $0 "$@"'
  if $running_under_some_shell;

use vars qw($running_under_some_shell);         # no whining!

# grepmail version 3.7

# Grepmail searches a normal, gzip'd, or bzip2'd mailbox for a given regular
# expression and returns those emails that match the query. It also supports
# piped compressed or ascii input, and searches constrained by date. 

# If you would like to be notified of updates, send email to me at
# coppit@cs.virginia.edu. The latest version is always at
# http://www.cs.virginia.edu/~dwc3q/code/.

# Do a pod2text on this file to get full documentation, or pod2man to get
# man pages.

# Written by David Coppit (coppit@cs.virginia.edu,
#  http://www.cs.virginia.edu/~dwc3q/index.html)

# Please send me any modifications you make. (for the better, that is. :) I
# have a suite of tests that I can give you if you ask. Keep in mind that I'm
# likely to turn down obscure features to avoid including everything but the
# kitchen sink.

# This code is distributed under the GNU General Public License (GPL). See
# http://www.opensource.org/gpl-license.html and http://www.opensource.org/.

# Notes:
# It turns out that -h, -b, and -v have some nasty feature interaction. Here's
# a table of how matching should occur for each combination of flags:
#
#  B, H,!V
#  Match if body and header matches
#  B,!H,!V
#  Match if body matches -- don't care about header
# !B, H,!V
#  Match if header matches -- don't care about body
# -V strictly inverts each of the above cases.
#
#  The best way to think about this is using Venn diagrams. (Especially when
#  trying to figure out whether the header uniquely determines whether the
#  email matches.)

use Getopt::Std;

use vars qw(%opts $pattern $commandLine);

# We need to do this early to check for the -D flag when setting the DEBUG
# constant
BEGIN
{
  $commandLine = "$0 @ARGV";

  # Print usage error if no arguments given
  print "No arguments given. grepmail -h for help.\n" and exit if (!@ARGV);

  getopt("ed",\%opts);
}

use constant DEBUG => $opts{D} || 0;

require 5.00396;

use strict;
use FileHandle;
use Carp;

sub usage
{
<<EOF;
usage: grepmail [-bDhilmrv] [[-e] <expr>] [-d \"datespec\"] <files...>

-b Search must match body
-d Specify a date range (see below)
-D Debug mode
-e Explicitely name expr (when searching for strings beginning with "-")
-h Search must match header
-i Ignore case in the search expression
-l Output the names of files having an email matching the expression
-m Append "X-Mailfolder: <folder>" to all headers to indicate in which folder
   the match occurred
-r Output the names of the files and the number of emails matching the
   expression
-v Output emails that don't match the expression

Date specifications must be of the form of:
a date like "today", "1st thursday in June 1992", "05/18/93",
  "12:30 Dec 12th 1880", "8:00pm december tenth",
OR "before", "after", or "since", followed by a date as defined above,
OR "between <date> and <date>", where <date> is defined as above.

Files can be plain ASCII or ASCII files compressed with gzip, tzip, or bzip2.
You can also pipe normal or compressed ASCII to grepmail.
EOF
}

#-------------------------------------------------------------------------------

sub dprint
{
  return unless DEBUG;

  my $message = join '',@_;

  my @lines = split /\n/, $message;
  foreach my $line (@lines)
  {
    print "DEBUG: $line\n";
  }
}

#-------------------------------------------------------------------------------

sub cleanExit
{
  my $message;

  if (@_)
  {
    $message = shift;
  }
  else
  {
    $message = "Cancelled";
  }

  print "$message.\n";

  exit;
}

#-------------------------------------------------------------------------------

dprint "Command line was:";
dprint "  $commandLine";

# At this point, we have 4 cases:
# - The -d was specified without a pattern before it, in which case $opts{d}
#   will be set. An implicit "." is used unless -e was specified.
# - The pattern is in $ARGV[0], and -d is in $ARGV[1]
# - There is no -d in $ARGV[1], and a pattern or file is in $ARGV[0]. Take
#   is as a pattern if -e was not given.
# - They did something like "grepmail -h", in which case do nothing
if ($opts{d})
{
  $pattern = "." if !$opts{e};
}
elsif ($#ARGV > 0 && $ARGV[1] eq "-d")
{
  $pattern = shift @ARGV;
  getopt("d",\%opts);
}
elsif (!$opts{e} && @ARGV)
{
  $pattern = shift @ARGV;
}

if (DEBUG)
{
  dprint "Options are:";
  foreach my $i (keys %opts)
  {
    dprint "  $i: $opts{$i}";
  }

  dprint "INC is:";
  foreach my $i (@INC)
  {
    dprint "  $i";
  }
}

if ($opts{e})
{
  print "You specified two search patterns.\n" and exit if (defined $pattern);
  
  $pattern = $opts{e};
}
elsif (!defined $pattern)
{
  # The only time you can't specify the pattern is when -d is being used.
  # This should catch people who do "grepmail -h" thinking it's help.
  print usage and exit if !$opts{d};

  $pattern = ".";
}

if ($opts{d})
{
  unless (eval "require Date::Parse")
  {
    print "You specified -d, but do not have Date::Parse. Get it from CPAN.\n";
    exit;
  }

  import Date::Parse;
}

#-------------------------------------------------------------------------------

sub IsMailbox
{
my $fileHandle = shift @_;

read($fileHandle,$_[0],500) unless $_[0] ne '';

return 1 if $_[0] =~ /^from: /im &&
            $_[0] =~ /^subject: /im &&
            $_[0] =~ /^date: /im;
return 0;
}
#-------------------------------------------------------------------------------

# Make the pattern insensitive if we need to
$pattern = "(?i)$pattern" if ($opts{i});

my ($dateRestriction, $date1, $date2);

if ($opts{d})
{
  ($dateRestriction,$date1,$date2) = ProcessDate($opts{d});
}
else
{
  $dateRestriction = "none";
}

dprint "PATTERN: $pattern\n";
dprint "FILES: @ARGV\n";

# Catch everything I can...
$SIG{PIPE} = \&cleanExit;
$SIG{HUP} = \&cleanExit;
$SIG{INT} = \&cleanExit;
$SIG{QUIT} = \&cleanExit;
$SIG{TERM} = \&cleanExit;

# If the user provided input files...
if (@ARGV)
{
  # For each input file...
  foreach my $file (@ARGV)
  {
    dprint "######################################################";
    dprint "Processing file $file";

    # First of all, silently ignore empty files...
    next if -z $file;

    # ...and also ignore directories.
    warn "** Skipping directory: '$file' **\n" and next if -d $file;

    my $fileHandle = new FileHandle;

    # If it's not a compressed file
    if ($file !~ /\.(gz|Z|bz2|tz)$/)
    {
      warn "** Skipping binary file: '$file' **\n" and next if -B $file;

      $fileHandle->open($file) || cleanExit "Can't open $file";
    }
    # If it is a tzipped file
    elsif ($file =~ /\.tz$/)
    {
      dprint "Calling tzip to decompress file.";
      $fileHandle->open("tzip -cd $file|") 
        or cleanExit "Can't execute tzip for file $file";
    }
    # If it is a gzipped file
    elsif ($file =~ /\.(gz|Z)$/)
    {
      dprint "Calling gunzip to decompress file.";
      $fileHandle->open("gunzip -c $file|")
        or cleanExit "Can't execute gunzip for file $file";
    }
    # If it is a bzipped file
    elsif ($file =~ /\.bz2$/)
    {
      dprint "Calling bzip2 to decompress file.";
      $fileHandle->open("bzip2 -dc $file|")
        or cleanExit "Can't execute bzip2 for file $file";
    }

    my $buffer = '';

    warn "** Skipping non-mailbox ASCII file: '$file' **\n" and next
      unless IsMailbox($fileHandle,$buffer);

    ProcessMailFile($fileHandle,$file,$buffer);
    $fileHandle->close();
  }
}
# Using STDIN
else
{ 
  dprint "Handling STDIN";

  # We have to implement our own -B and -s, because STDIN gets eaten by them
  binmode STDIN;

  my ($testChars,$isEmpty,$isBinary);

  $isEmpty = 0;
  $isBinary = 0;

  # Be sure to read at least 500 characters so that IsMailbox will work
  # correctly
  $isEmpty = 1 if !read(STDIN,$testChars,500);

  # This isn't the "real" way to do -B, but it should work okay.
  $isBinary = 1 if !$isEmpty &&
                    ($testChars =~ /\000/ || $testChars =~ /[\200-\377]/);

  # If it looks binary and is non-empty, try to uncompress it. Here we're
  # calling another copy of grepmail through the open command.
  if ($isBinary)
  {
    my $filter;

    # This seems to work. I'm not sure what the "proper" way to distinguish
    # between gzip'd and bzip2'd and tzip'd files is.
    if ($testChars =~ /^TZ/)
    {
      dprint "Trying to decompress using tzip.";
      $filter = "tzip -dc";
    }
    elsif ($testChars =~ /^BZ/)
    {
      dprint "Trying to decompress using bzip2.";
      $filter = "bzip2 -d";
    }
    else
    {
      dprint "Trying to decompress using gunzip.";
      $filter = "gunzip -c";
    }

    # Here we invoke another copy of grepmail with a filter in front. We
    # send it the test characters, then whatever is left on stdin.
    my $fileHandle = new FileHandle;
    $fileHandle->open("|$filter|$commandLine")
      or cleanExit "Can't execute '$filter' on stdin";
    print $fileHandle $testChars;
    print $fileHandle <STDIN>;
    close $fileHandle;
  }
  # Otherwise process it directly
  else
  {
    warn "** Skipping non-mailbox standard input **\n" and exit
      unless IsMailbox(*STDIN,$testChars);

    # It's really bad to pass the test characters with the input stream,
    # but I don't know of another way to do what I want.
    # (Well, okay, I could create a class that encapsulates STDIN and uses a
    # buffer to allow you to read without removing data from the stream. When
    # the buffer is empty, it reads from the real STDIN.)
    ProcessMailFile(*STDIN,"Standard input",$testChars);
  }
}

#-------------------------------------------------------------------------------

# $firstChars is used because the caller might have read some stuff off of
# STDIN, and couldn't put it back for use here.
sub ProcessMailFile ($$)
{
my $fileHandle = shift @_;
my $fileName = shift @_;
my $firstChars = shift @_;

my ($numberOfMatches,$matchesBody,$matchesHeader,$paragraph,$email_buffer,
    $header_buffer);

$email_buffer = '';
$header_buffer = undef;
$numberOfMatches = 0;

# Read whole paragraphs
$/ = "\n\n";

# This is the main loop. It's executed once for each email
while (!eof($fileHandle))
{
  $email_buffer='';
  
  # Read the header for the first email
  if (!defined $header_buffer)
  {
    dprint "Getting header for first email.";
    if (defined $firstChars)
    {
      $paragraph = $firstChars;
      undef $firstChars;
      $paragraph .= <$fileHandle>;
    }
    else
    {
      $paragraph = <$fileHandle>;
    }
  }
  else
  {
    dprint "Processing buffered header.";
    $paragraph = $header_buffer;
    undef $header_buffer;
  }

  $email_buffer .= $paragraph;

  if (DEBUG)
  {
    dprint "------------------------------------------------------";
    dprint "Processing email:";
    $paragraph =~ /^(from:.*)$/im;
    dprint "  $1";
    $paragraph =~ /^(subject:.*)$/im;
    dprint "  $1";
  }

  # Save the header for later when we check the date.
  my $header = $paragraph;

  my ($matchesHeader,$matchesBody); 

  # See if the header matches the pattern
  $matchesHeader = ($paragraph =~ /$pattern/om);

  # At this point, we might know enough to print the email.
  if (
      ($opts{h} && $opts{b} && $opts{v} && !$matchesHeader) ||
      ($opts{h} && !$opts{b} && $opts{v} && !$matchesHeader) ||
      (!$opts{h} && !$opts{b} && !$opts{v} && $matchesHeader)
     )
  {
    dprint "Checking for early printout based on header.";

    # Skip to the next email if the date is wrong.
    if (!CheckDate(\$header))
    {
      dprint "Header failed date constraint.";
      SkipToNextEmail($fileHandle,\$header_buffer);
      next;
    }

    dprint "Doing an early printout based on header match.";

    if ($opts{l})
    {
      print "$fileName\n";

      # We can return since we found at least one email that matches.
      return;
    }
    elsif ($opts{r})
    {
      $numberOfMatches++;
      SkipToNextEmail($fileHandle,\$header_buffer);
    }
    else
    {
      PrintEmail($fileHandle,$fileName,$email_buffer,\$header_buffer);
    }

    next;
  }

  # We might have enough information to abort early
  if (
      ($opts{h} && $opts{b} && !$opts{v} && !$matchesHeader) ||
      ($opts{h} && !$opts{b} && !$opts{v} && !$matchesHeader) ||
      ($opts{h} && !$opts{b} && $opts{v} && !$matchesHeader) ||
      (!$opts{h} && !$opts{b} && $opts{v} && $matchesHeader)
     )
  {
    dprint "Doing an early abort based on header.";

    SkipToNextEmail($fileHandle,\$header_buffer);
    next;
  }

  dprint "Searching body for pattern.";

  # Now search the body for the pattern
  do
  {
    $paragraph = <$fileHandle>;
    $email_buffer .= $paragraph;
  }
  while (!eof && ($paragraph !~ /^\n?From .*\d{4}/) &&
        ($paragraph !~ /$pattern/om));

  if (eof)
  {
    dprint "Found EOF.";
    $matchesBody = 0;
  }
  elsif ($paragraph =~ /^\n?From .*\d{4}/)
  {
    dprint "Found next email's header, buffering.";
    $header_buffer = $paragraph;
    $matchesBody = 0;
  }
  else
  {
    $matchesBody = ($paragraph =~ /$pattern/om);
  }

  my $isMatch = (
                 ($opts{b} && $opts{h} && $matchesBody && $matchesHeader) ||
                 ($opts{b} && !$opts{h} && $matchesBody) ||
                 (!$opts{b} && $opts{h} && $matchesHeader) ||
                 (!$opts{b} && !$opts{h} && ($matchesBody || $matchesHeader))
                );

  $isMatch = !$isMatch if $opts{v};

  # If the match occurred in the right place...
  if ($isMatch)
  {
    dprint "Found a pattern match on the body.";

    # Skip to the next email if the date is wrong.
    if (!CheckDate(\$header))
    {
      dprint "Failed date constraint.";

      SkipToNextEmail($fileHandle,\$header_buffer);
      next;
    }

    if ($opts{l})
    {
      print "$fileName\n";

      # We can return since we found at least one email that matches.
      return;
    }
    elsif ($opts{r})
    {
      $numberOfMatches++;
      SkipToNextEmail($fileHandle,\$header_buffer);
    }
    else
    {
      PrintEmail($fileHandle,$fileName,$email_buffer,\$header_buffer);
    }
  }
  else
  {
    dprint "Did not find a pattern match on the body.";

    # It doesn't match the pattern
    SkipToNextEmail($fileHandle,\$header_buffer);
  }
}

 print "$fileName: $numberOfMatches\n" if ($opts{r});
}

#-------------------------------------------------------------------------------

sub SkipToNextEmail($\$)
{
  my $fileHandle = shift;
  my $header_buffer = shift;
  my $paragraph;

  dprint "Skipping to next email.";

  # If we have something buffered, it's the beginning of the next email
  # address, so we don't need to do anything. Joy.
  return if defined $$header_buffer;

  do
  {
    $paragraph = <$fileHandle>;
  }
  while (!eof && ($paragraph !~ /^\n?From .*\d{4}/)) ;

  # Buffer if we went too far.
  $$header_buffer = $paragraph if (!eof);
}

#-------------------------------------------------------------------------------

sub PrintEmail($$$\$)
{
  my $fileHandle = shift;
  my $fileName = shift;
  my $email_buffer = shift;
  my $header_buffer = shift;
  
  # Read in and process parts of message we already have.
  my ($paragraph, @paragraphs);
  foreach $paragraph (split(/\n\n/,$email_buffer))
  {
    push @paragraphs, "$paragraph\n\n";
  }
  undef $paragraph;
  
  # Read in remainder of message, if necessary.
  if ((!defined $$header_buffer) && (!eof))
  {
    do
    {
      $paragraph = <$fileHandle>;
      push @paragraphs, $paragraph;
    }
    while (!eof && ($paragraph !~ /^\n?From .*\d{4}/)) ;

    # Buffer if we read too far.
    $$header_buffer = $paragraph if (!eof);
  }

  dprint "Printing email.";
  $paragraph = shift @paragraphs;

  # Strip any newline at the start of the header. Because the pattern is
  # "\n\n", there will sometimes be an extra newline if there are an odd
  # number of newlines between emails.
  $paragraph =~ s/^\n(From .*\d{4})/$1/;

  # Print the mailfolder in the headers if -m was given
  if ($opts{"m"})
  {
    chop $paragraph;
    $paragraph .= "X-Mailfolder: $fileName\n\n";
  }
  print $paragraph;

  do
  {
    $paragraph = shift @paragraphs;

    print $paragraph if $paragraph !~ /^\n?From .*\d{4}/;

    # Print the extra newline that appears when there are an odd number of
    # newlines bewteen messages. Basically I consider the newline to be part
    # of the previous message, although I don't think it matters.
    if ($paragraph =~ /^\nFrom .*\d{4}/)
    {
      $paragraph =~ s/^\n//;
      print "\n";
    }
  }
  while (@paragraphs && ($paragraph !~ /^\n?From .*\d{4}/)) ;
}

#-------------------------------------------------------------------------------
    
sub CheckDate($)
{
my $emailref = shift;
my ($emailDate, $isInDate);
$emailDate = "";
$isInDate = 0;

if ($opts{d})
{
  # The email might not have a date. In this case, print it out anyway.
  if ($$emailref =~ /^Date:\s*(\S*\s*\S*\s*\S*\s*\S*\s*\S*)/m)
  {
    dprint "Date in email is: $1.";

    $emailDate = str2time($1);
    $isInDate = IsInDate($emailDate,$dateRestriction,$date1,$date2);
  }
  else
  {
    dprint "No date found in email.";

    $isInDate = 1;
  }
}
else
{
  $isInDate = 1;
}

return $isInDate;

}

#-------------------------------------------------------------------------------

sub ParseDate
{
  my $time = shift;

  my $today = str2time("".((localtime)[4]+1).'/'.((localtime)[3]).'/'.
       ((localtime)[5]+1900));

  if ($time =~ /^\s*today\s*$/i)
  {
    return $today;
  }
  elsif ($time =~ /^\s*yesterday\s*$/i)
  {
    return $today-60*60*24;
  }
  elsif ($time =~ /^\s*(\d+) days? ago\s*$/i)
  {
    return $today-60*60*24*$1;
  }
  elsif ($time =~ /^\s*(\d+) weeks? ago\s*$/i)
  {
    return $today-60*60*24*7*$1;
  }
  else
  {
    return str2time($time);
  }
}

#-------------------------------------------------------------------------------

# Figure out what kind of date restriction they want, and what the dates in
# question are.
sub ProcessDate($)
{
my ($dateRestriction, $date1, $date2);

my $datestring = shift;

if(!defined($datestring))
{
  return ("none","","");
}

if ($datestring =~ /^before (.*)/i)
{
  $dateRestriction = "before";
  $date1 = ParseDate($1);
  $date2 = "";

  cleanExit "\"$1\" is not a valid date" if (!$date1);
}
elsif ($datestring =~ /^(after |since )(.*)/i)
{
  $dateRestriction = "after";
  $date1 = ParseDate($2);
  $date2 = "";

  cleanExit "\"$2\" is not a valid date" if (!$date1);
}
elsif ($datestring =~ /^between (.*) and (.*)/i)
{
  $dateRestriction = "between";
  $date1 = ParseDate($1);
  $date2 = ParseDate($2);

  cleanExit "\"$1\" is not a valid date" if (!$date1);
  cleanExit "\"$2\" is not a valid date" if (!$date2);

  # Swap the dates if the user gave them backwards.
  if ($date1 > $date2)
  {
    my $temp;
    $temp = $date1;
    $date1 = $date2;
    $date2 = $temp;
  }

}
elsif (ParseDate($datestring) ne '')
{
  $dateRestriction = "on";
  $date1 = ParseDate($datestring);
}
else
{
  cleanExit "Invalid date specification. Use \"$0 -h\" for help";
}

return ($dateRestriction,$date1,$date2);

}

#-------------------------------------------------------------------------------

sub IsInDate($$$$)
{
my ($emailDate,$dateRestriction,$date1,$date2);
$emailDate = shift @_;
$dateRestriction = shift @_;
$date1 = shift @_;
$date2 = shift @_;

# Here we do the date checking.
if ($dateRestriction eq "none")
{
  return 1;
}
else
{
  if ($dateRestriction eq "before")
  {
    if ($emailDate < $date1)
    {
      return 1;
    }
    else
    {
      return 0;
    }
  }
  elsif ($dateRestriction eq "after")
  {
    if ($emailDate > $date1)
    {
      return 1;
    }
    else
    {
      return 0;
    }
  }
  elsif ($dateRestriction eq "on")
  {
    if ($emailDate == $date1)
    {
      return 1;
    }
    else
    {
      return 0;
    }
  }
  elsif ($dateRestriction eq "between")
  {
    if (($emailDate > $date1) && ($emailDate < $date2))
    {
      return 1;
    }
    else
    {
      return 0;
    }
  }
}

}

#-------------------------------------------------------------------------------

=head1 NAME

grepmail - search mailboxes for mail matching a regular expression

=head1 SYNOPSIS

  grepmail [-vihblrm] [-e <regex>] [-d "datespec"] [mailbox ...]

=head1 DESCRIPTION

=over 2

I<grepmail> looks for mail messages containing a pattern, and prints the
resulting messages on standard out.

By default I<grepmail> looks in both header and body for the specified pattern.

When redirected to a file, the result is another mailbox, which can, in turn,
be handled by standard User Agents, such as I<elm>, or even used as input for
another instance of I<grepmail>.

The pattern is optional if -d is used, and must precede the -d flag unless it
is specified using -e.

=back

=head1 OPTIONS AND ARGUMENTS

Many of the options and arguments are analogous to those of grep.

=over 8

=item B<pattern>

The pattern to search for in the mail message.  May be any Perl regular
expression, but should be quoted on the command line to protect against
globbing (shell expansion). To search for more than one pattern, use the form
"(pattern1|pattern2|...)".

=item B<mailbox>

Mailboxes must be traditional, UNIX C</bin/mail> mailbox format.  The
mailboxes may be compressed by gzip, bzip2, or tzip, in which case gunzip,
bzip2, or tzip must be installed on the system.

If no mailbox is specified, takes input from stdin, which can be compressed or
not. grepmail's behavior is undefined when ASCII and binary data is piped
together as input.

=item B<-b>

Asserts that the pattern must match in the body of the email.

=item B<-D>

Enable debug mode, which prints diagnostic messages.

=item B<-d>

Date specifications must be of the form of:
  - a date like "today", "yesterday", "5/18/93", "5 days ago", "5 weeks ago",
  - OR "before", "after", or "since", followed by a date as defined above,
  - OR "between <date> and <date>", where <date> is defined as above.

=item B<-e>

Explicitely specify the search pattern. This is useful for specifying patterns
that begin with "-", which would otherwise be interpreted as a flag.

=item B<-h>

Asserts that the pattern must match in the header of the email.

=item B<-i>

Make the search case-insensitive (by analogy to I<grep -i>).

=item B<-l>

Output the names of files having an email matching the expression, (by analogy
to I<grep -l>).

=item B<-m>

Append "X-Mailfolder: <folder>" to all email headers, indicating which folder
contained the matched email.

=item B<-r>

Generate a report of the names of the files containing emails matching the
expression, along with a count of the number of matching emails.

=item B<-v>

Invert the sense of the search, (by analogy to I<grep -v>). Note that this
affects only -h and -b, not -d. This results in the set of emails printed
being the complement of those that would be printed without the -v switch.

=back

=head1 EXAMPLES

Get all email that you mailed yesterday

  grepmail -d yesterday sent-mail

Get all email that you mailed before the first of June 1998 that
pertains to research:

  grepmail research -d "before 6/1/92" sent-mail

Get all email you received since 8/20/98 that wasn't about research or your
job, ignoring case:

  grepmail -iv "(research|job)" -d "since 8/20/98" saved-mail

Get all email about mime but not about Netscape. Constrain the search to match
the body, since most headers contain the text "mime":

  grepmail -b mime saved-mail | grepmail Netscape -v

Print a list of all mailboxes containing a message from Rodney. Constrain the
search to the headers, since quoted emails may match the pattern:

  grepmail -hl "^From.*Rodney" saved-mail*

Find all emails with the text "Pilot" in both the header and the body:

  grepmail -hb "Pilot" saved-mail*

Print a count of the number of messages about grepmail in all saved-mail
mailboxes:

  grepmail -br grepmail saved-mail*

=head1 FILES

grepmail will I<not> create temporary files while decompressing compressed
archives. The last version to do this was 3.5. While the new design uses
more memory, the code is much simpler, and there is less chance that email
can be read by malicious third parties. Memory usage is determined by the size
of the largest email message in the mailbox.

=head1 AUTHOR

  David Coppit, <coppit@cs.virginia.edu>,
  http://www.cs.virginia.edu/~dwc3q/index.html

=head1 SEE ALSO

elm(1), mail(1), grep(1), perl(1), printmail(1), Mail::Internet(3)
Crocker,  D.  H., Standard for the
Format of Arpa Internet Text Messages, RFC822.

=cut
